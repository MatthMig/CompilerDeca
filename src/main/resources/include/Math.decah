// Grenoble INP - Ensimag projet GL -*- mode: java -*-
// Library for class Math of Deca, coded in Deca

class Math {

    float _pi = 3.141592653589793;
    float _floatMinimumValue = 1.4E-45;

    float _abs(float f){
        if( f < 0){
            return -f;
        } else {
            return f;
        }
    }

    float _pow(float x, float pow) {
        if (pow == 0.0) {
            return 1.0;
        }
        if (pow == 1.0) {
            return x;
        }
        if (pow == -1.0) {
            return -x;
        }
        float result = 1.0;
        while (pow > 0) {
            result = result * x;
            pow = pow - 1;
        }
    }

    float _sqrt(float f){
        float precision = 0.0001;
        float approximation = f/2.0;
        
        while (abs(_pow(approximation, 2)- f) > precision) {
            approximation = (approximation + f / approximation) / 2;
        }
        
        return approximation;
    }

    float reduceAngle(float x) {

        x = x % (2 * _pi);
        
        if (x > _pi) {
            x = x - (2 * _pi);
        } else if (x < -_pi) {
            x = x + (2 * _pi);
        }
        
        return x;
    }

    float sin(float f) {
        x = reduceAngle(x);

        float result = 0;
        float term = x;
        float power = x;
        float factorial = 1;
        int sign = 1;
        int i = 1;

        while (i <= 10) {
            result = result + (sign * term / factorial);
            power = power * x * x;
            factorial = factorial * (i + 1) * (i + 2);
            sign = sign * (-1);
            i = i + 2;
            term = power / factorial;
        }

        return result;
    }

    float cos(float f) {

        f = f % ( 2 * _pi);
        float init = 1.0;
        float sum = 1.0;
        float fact = -1.0;
        int i = 1;
        
        while (_abs(init) > 0.0000001) {
            fact = fact * (-1.0);
            init = init * f * f / (2 * i * (2 * i - 1));
            sum = sum + fact * init;
            i = i + 1;
        }

        return sum;
    }

    float asin(float f) {

        if (f > 1 || f < -1) {
            println("Erreur : x doit être compris entre -1 et 1");
        }

        float precision = 1e-8;
        float estimation = f;
        float difference = precision + 1;

        while (difference > precision) {
            float derive = 1 / _sqrt(1-_pow(estimation, 2.0));
            float correction = (estimation - f) / derivee;
            estimation = estimation - correction;
            difference = _abs(correction);
        }

        return estimation;
    }

    float _atan_approximation(float f){
        int iterations = 5;  // Nombre d'itérations pour l'approximation

        float result = 0;
        float power = f;
        float divisor = 1;
        boolean is_addition = true;
        int i = 1;

        while (i <= iterations) {
            float term = power / divisor;

            if (is_addition) {
                result += term;
            } else {
                result -= term;
            }

            power = power * f * f;
            divisor = divisor + 2;
            is_addition = !is_addition;

            i = i + 1;
        }

        return result;
    }
    // Methode d approximation de la serie de Taylor
    float atan(float f) {
        if (f == 0) {
            return
        }

        int sign;
        if (f > 0){
            sign = 1;
        } else{
            sign = -1;
        }

        f = _abs(f);
        if(f > 1){
            f = 1/f;
            float atan_val = (_pi / 2) - _atan_approximation(f);
            return sign * atan_val;
        } else {
            float atan_val = _atan_approximation(f);
            return sign * atan_val;
        }
    }


    float ulp(float f) {

        // Cas particulier pour zéro
        if (f == 0.0) {
            return _floatMinimumValue;
        }

        // Calcul du signe
        float signe = 1.0;
        if (f < 0.0) {
            signe = -1.0;
        }
            
        // Calcul de la mantisse et de l'exposant
        float mantisse = f * signe;
        int exposant = 0;

        while (mantisse < 0.5) {
            mantisse = mantisse / 2.0;
            exposant = exposant - 1;
        }

        // Calcul de l'ulp
        float ulp = _puissance(2.0, exposant);

        // Retourne l'ulp multiplié par le signe de f
        return ulp * signe;

    }
   
}


// End of Deca Math library