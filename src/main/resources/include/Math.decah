// Grenoble INP - Ensimag projet GL -*- mode: java -*-
// Library for class Math of Deca, coded in Deca

class Math {

    float _floatMinimumValue = 1.4E-45;

    float _abs(float f){
        if( f < 0){
            return -f;
        } else {
            return f;
        }
    }

    float _puissance(float a, float puissance) {
        if (puissance == 0.0) {
            return 1.0;
        }
        if (puissance == 1.0) {
            return a;
        }
        if (puissance == -1.0) {
            return -a;
        }
        float resulat = 1.0;
        while (puissance > 0) {
            resultat = resultat * a;
            puissance = puissance - 1;
        }
    }

    float sin(float f) {
        println("sin(f) not yet implemented");
    }
    float cos(float f) {
        println("cos(f) not yet implemented");
    }
    float asin(float f) {
        println("asin(f) not yet implemented");
    }

    // Methode d approximation de la serie de Taylor
    float atan(float f) {
        println("atan(f) not yet implemented");
        if (f == 0) {
            return
        }

        int sign;
        if (f > 0){
            sign = 1;
        } else{
            sign = -1;
        }

        f = _abs(f);
        if(f > 1){
            f = 1/f;
            float atan_val = (3.141592653589793 / 2) - _atan_approximation(f);
            return sign * atan_val;
        } else {
            float atan_val = _atan_approximation(f);
            return sign * atan_val;
        }
    }

    float _atan_approximation(float f){
        int iterations = 5;  // Nombre d'itérations pour l'approximation

        float result = 0;
        float power = f;
        float divisor = 1;
        boolean is_addition = true;
        int i = 1;

        while (i <= iterations) {
            double term = power / divisor;

            if (is_addition) {
                result += term;
            } else {
                result -= term;
            }

            power = power * f * f;
            divisor = divisor + 2;
            is_addition = !is_addition;

            i = i + 1;
        }

        return result;
    }


    float ulp(float f) {

        // Cas particulier pour zéro
        if (f == 0.0) {
            return _floatMinimumValue;
        }

        // Calcul du signe
        float signe = 1.0;
        if (f < 0.0) {
            signe = -1.0;
        }
            
        // Calcul de la mantisse et de l'exposant
        float mantisse = f * signe;
        int exposant = 0;

        while (mantisse < 0.5) {
            mantisse = mantisse / 2.0;
            exposant = exposant - 1;
        }

        // Calcul de l'ulp
        float ulp = _puissance(2.0, exposant);

        // Retourne l'ulp multiplié par le signe de f
        return ulp * signe;

    }
}


// End of Deca Math library