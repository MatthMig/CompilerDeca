Commentez

ligne 7 -> _floatMinimumValue positif donc minimum seulement positif ? 
    peut être plutot _floatAbsMinimumValue ou _floatMaxPrecision

methode puissance : 
     cas avec valeur négative pour la puissance et valeur négative:
      gérer le cas avec des inputs x = -4 et pow -2 ==> ERROR 
      équivalent à la racine carrée d'un nombre négative 


    // Description :
    // 
    //      methode appelée lors d'une racine paire d'un nombre négative afin de mener à une erreur
    // 
    // Inputs : 
    //
    //      N/A 
    //
    // Resultat : 
    // 
    //      vous avez saisi une racine paire d'une valeur négative et ceci est impossible 
    //      ERROR

      void error_racine_negative()
      asm ("
            WSTR "vous avez saisi une racine paire d'une valeur négative et ceci est impossible"
            WNL
            ERROR
            
      
         ");

Nous pouvons donc appeler cette methode en ima pour arreter le programme lors de cette erreur.
Nous devons donc appeler cette methode lors de la condition où nous avons un pow <1 de forme 1/n avec n paire
et une valeur x négative.

    PENSEZ A DECLARER TOUTES LES VARIABLES AU DEBUT DE LA METHODE SINON CELA NE MARCHE PAS
    VOUS POUVEZ LES INITIALISER QUAND VOUS LE VOULEZ
 

methode racine carrée : 

    PENSEZ A RE UTILISER CE QUE VOUS AVEZ UTILISER AVANT ==> pour la sqrt pensez a re UTILISER
    la fonction pow en passant en parametre le x qui descend de la methode sqrt puis le pow avec 1/2
    les erreurs seront gérées par la methode pow.

    exemple : 

    // Description : 
    // 
    //      Methode racine carrée qui appelle la methode _pow avec une pow fixée à 0.5
    //
    // Input :
    // 
    //      float f
    // 
    // Résultat : 
    // 
    //      racine_carré(f)
^

        float _sqrt (float f){
            return _pow(f,0.5);
        }

0ngle pour un calcul de sinus

modulo remplacé possiblement par une boucle == > cela nous permettrait d'utiliser cette methode reduceAngle
avec des floats .

sin : 

    revoir les floats si on les garde ou pas selon la boucle dans reduceAngle ou le modulo
    sin respecte bien le deca; A voir pour lalgo mais on vous fait confiance


cos : 

    cf floats / modulo / boucle
    cos passe aussi le langage deca ; Pareil pour lalgo


asin : 

    au premier if , pensez plutôt a créer une methode asm qui print le msg derreur 
    et renvoie lerreur directement

    exemple : 


 // Description :
    // 
    //      methode appelée lors du message d'erreur dans asin premier if 
    // 
    // Inputs : 
    //
    //      N/A 
    //arctan(1000)
    // Resultat : 
    // 
    //      la valeur doit être entre -1 et 1
    //      ERROR

      void error_param_asin()
      asm ("
            WSTR "la valeur doit être entre -1 et 1"
            WNL
            ERROR
            
      
         ");

         a voir : utiliser la valeur absolue pour la condition au lieu d'un ou
         truc de maxeur mais comme vous voulez. ne pas forcement utiliser valeur absolue
         car si tas un probleme avec, tes dans la merde

         voir lécriture de precision = 1e-8 
         plutot float precision = 0,00000001

         toujours penser a defnir au debut et initialiser apres



float atan_approximation(float f) : RAS

float atan(float f)

return tout court pas possible et sans ";" encore moins

pour arctan(0) :

return 0;

TOUJOURS PENSER A DECLARER AU DEBUT ET INITIALISER QUAND VOUS VOULEZ


question du float encore

si tu return la meme dans if else 

le sortir du if

float ulp(float f)


TOUJOURS DECLARER AU DEBUT ET DEFINIR QUAND VOUS VOULEZ
 ras ulp 